import os
import asyncio
import nest_asyncio
import requests
from flask import Flask, request
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    MessageHandler, filters, ContextTypes, ConversationHandler
)

# ==== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¨ÙˆØª ====
TOKEN = os.environ.get("BOT_TOKEN")
WEBHOOK_URL = os.environ.get("WEBHOOK_URL")

CHOOSING, TYPING_CONFESSION, AFTER_CONFESSION, CHOOSING_EXERCISE, TYPING_EXERCISE = range(5)
confessions_storage = []

GOOGLE_SHEET_URL = "https://script.google.com/macros/s/XXX/exec"  # Ø¹Ø¯Ù‘Ù„ÙŠÙ‡ Ø¹Ù†Ø¯ Ø§Ù„Ø­Ø§Ø¬Ø©

# ==== Ø¥Ø¹Ø¯Ø§Ø¯ ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ÙˆÙŠØ¨ (Webhook) ====
app = Flask(__name__)

@app.route('/')
def home():
    return "âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†â€¦"

@app.route(f"/{TOKEN}", methods=['POST'])
def webhook():
    update = Update.de_json(request.get_json(force=True), application.bot)
    asyncio.create_task(application.process_update(update))
    return 'ok'

# ==== ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø¨ÙˆØª ====
async def send_to_sheet(entry_type, content):
    try:
        requests.post(GOOGLE_SHEET_URL, json={
            "type": entry_type,
            "content": content,
            "source": "Telegram Bot"
        })
    except Exception as e:
        print("Error sending to sheet:", e)

WELCOME_TEXT = """
ğŸ–¤ Ù…Ø±Ø­Ø¨Ù‹Ø§ ÙÙŠ Ø¨Ù„Ø§Ùƒ Ø¯ÙØªØ±

âœ¦ Ø§Ø®ØªØ§Ø±ÙŠ Ù…Ø§ ØªØ±ØºØ¨ÙŠÙ† Ø¨Ù‡ Ù…Ù† Ù‡Ø°Ù‡ Ø§Ù„Ù…Ø³Ø§Ø­Ø© Ø§Ù„Ø¢Ù†:
"""

MAIN_MENU = [
    [InlineKeyboardButton("âœï¸ Ø§Ø¹ØªØ±Ø§Ù", callback_data='confess')],
    [InlineKeyboardButton("ğŸ“š Ø§Ù„Ù…ÙƒØªØ¨Ø©", callback_data='library')],
]

BACK = [InlineKeyboardButton("â¬…ï¸ Ø§Ù„Ø¹ÙˆØ¯Ø©", callback_data='main_menu')]

CONFESSION_PROMPT = "ğŸ–¤ Ø§ÙƒØªØ¨ÙŠ Ø§Ø¹ØªØ±Ø§ÙÙƒ Ø§Ù„Ø¢Ù†â€¦"
POST_CONFESSION = "ğŸ–¤ Ù‡Ù„ ØªØ±ØºØ¨ÙŠÙ† ÙÙŠ ØªÙ…Ø±ÙŠÙ† Ø¨Ø¹Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø§Ø¹ØªØ±Ø§ÙØŸ"

POST_OPTIONS = [
    [InlineKeyboardButton("ğŸ¯ Ù†Ø¹Ù…", callback_data='exercise')],
    [InlineKeyboardButton("ğŸ”™ Ù„Ø§", callback_data='main_menu')],
]

LIBRARY_TEXT = """
ğŸ“˜ Ù…ÙƒØªØ¨Ø© Ø¨Ù„Ø§Ùƒ Ø¯ÙØªØ±

ğŸ”ª Ø¯ÙØªØ±Ù‡Ø§ Ø§Ù„Ø£Ø³ÙˆØ¯ â€“ Ø³ÙƒÙŠÙ† Ø£Ø¨ÙŠ  
ğŸ–‡ï¸ [Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†ØªØ¬](https://tinyurl.com/fatherscar)

ğŸ‘» Ø£Ø´Ø¨Ø§Ø­ Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ù„Ø§ ØªÙ…ÙˆØª  
ğŸ–‡ï¸ [Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù†ØªØ¬](https://tinyurl.com/goastmmry)
"""

EXERCISES_TEXT = """
ğŸ­ Ø§Ø®ØªØ§Ø±ÙŠ Ø§Ù„ØªÙ…Ø±ÙŠÙ† Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„ÙˆØ¬Ø¹Ùƒ:
"""
EXERCISE_OPTIONS = [
    [InlineKeyboardButton("ğŸ€ Ø·ÙÙˆÙ„Ø©", callback_data='child')],
    [InlineKeyboardButton("ğŸ’” Ø¹Ù„Ø§Ù‚Ø§Øª", callback_data='love')],
    [InlineKeyboardButton("âš”ï¸ Ù…Ø¹Ø§Ø±Ùƒ Ø¯Ø§Ø®Ù„ÙŠØ©", callback_data='war')],
    BACK
]

EXERCISE_RESPONSES = {
    'child': "ğŸ€ ØªØ®ÙŠÙ‘Ù„ÙŠ Ø·ÙÙ„ØªÙƒ Ø£Ù…Ø§Ù…Ùƒâ€¦ Ù…Ø§Ø°Ø§ ØªÙ‡Ù…Ø³ÙŠÙ† Ù„Ù‡Ø§ØŸ",
    'love': "ğŸ’” Ø§ÙƒØªØ¨ÙŠ Ø§Ø¹ØªØ±Ø§ÙÙƒ Ø§Ù„Ù…Ø±Ø¢ÙˆÙŠ: Ù…Ø§ Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ÙŠÙ† ØªØºÙŠÙŠØ±Ù‡ ÙÙŠ Ù†ÙØ³ÙƒØŸ",
    'war': "âš”ï¸ Ø§ÙƒØªØ¨ÙŠ ÙƒÙ„ Ù…Ø§ ØªØ­Ø§Ø±Ø¨ÙŠÙ†Ù‡ Ø¯Ø§Ø®Ù„Ùƒâ€¦ Ø«Ù… ØªÙ†ÙÙ‘Ø³ÙŠ."
}

# ==== Handlers ====
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(WELCOME_TEXT, reply_markup=InlineKeyboardMarkup(MAIN_MENU))
    return CHOOSING

async def main_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.callback_query.answer()
    await update.callback_query.edit_message_text(WELCOME_TEXT, reply_markup=InlineKeyboardMarkup(MAIN_MENU))
    return CHOOSING

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    if q.data == 'confess':
        await q.edit_message_text(CONFESSION_PROMPT)
        return TYPING_CONFESSION
    elif q.data == 'main_menu':
        return await main_menu(update, context)
    elif q.data == 'library':
        await q.edit_message_text(LIBRARY_TEXT, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup([BACK]))
        return CHOOSING
    elif q.data == 'exercise':
        await q.edit_message_text(EXERCISES_TEXT, reply_markup=InlineKeyboardMarkup(EXERCISE_OPTIONS))
        return CHOOSING_EXERCISE
    elif q.data in EXERCISE_RESPONSES:
        await q.edit_message_text(EXERCISE_RESPONSES[q.data], reply_markup=InlineKeyboardMarkup([BACK]))
        return TYPING_EXERCISE

async def handle_confession(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text.strip()
    await send_to_sheet("Ø§Ø¹ØªØ±Ø§Ù", msg)
    await update.message.reply_text(POST_CONFESSION, reply_markup=InlineKeyboardMarkup(POST_OPTIONS))
    return AFTER_CONFESSION

async def handle_exercise(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.message.text.strip()
    await send_to_sheet("ØªÙ…Ø±ÙŠÙ†", msg)
    await update.message.reply_text("âœ… ØªÙ… Ø­ÙØ¸ ØªÙ…Ø±ÙŠÙ†Ùƒ.", reply_markup=InlineKeyboardMarkup([BACK]))
    return CHOOSING

# ==== ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª ====
nest_asyncio.apply()
application = Application.builder().token(TOKEN).build()

conv_handler = ConversationHandler(
    entry_points=[CommandHandler("start", start)],
    states={
        CHOOSING: [CallbackQueryHandler(button_handler)],
        TYPING_CONFESSION: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_confession)],
        AFTER_CONFESSION: [CallbackQueryHandler(button_handler)],
        CHOOSING_EXERCISE: [CallbackQueryHandler(button_handler)],
        TYPING_EXERCISE: [MessageHandler(filters.TEXT & ~filters.COMMAND, handle_exercise)],
    },
    fallbacks=[CommandHandler("start", start)],
)
application.add_handler(conv_handler)

# Webhook
async def run_bot():
    await application.initialize()
    await application.bot.set_webhook(url=f"{WEBHOOK_URL}/{TOKEN}")
    await application.start()
    await application.updater.start_polling()
    print("âœ… Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†...")

asyncio.get_event_loop().create_task(run_bot())

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=8080)
